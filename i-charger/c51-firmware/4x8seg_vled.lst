C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 1   


C51 COMPILER V8.01, COMPILATION OF MODULE 4X8SEG_VLED
OBJECT MODULE PLACED IN 4x8seg_vled.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE driver\4x8seg_vled.c BROWSE INCDIR(.\driver) DEBUG OBJECTEXTEND PRINT(.\4x8
                    -seg_vled.lst) OBJECT(4x8seg_vled.obj)

line level    source

   1          
   2          #include <config.h>
   3          
   4          #include <4x8seg_vled.h>
   5          
   6          #define segENA1  P2_0
   7          #define segENA2  P2_1
   8          #define segENA3  P2_2
   9          #define segENA4  P2_3
  10          #define vledENA  P2_4
  11          #define segData  P0
  12          
  13          #define vledon()   segoff(0xF); vledENA=0;
  14          #define vledoff()  vledENA=1;
  15          
  16          
  17          
  18          #define segDOT  0X7F  /*dot*/
  19          
  20          
  21          
  22          #define segH   0X76,/*H*/
  23          #define segh   0X74,/*h*/
  24          #define segL   0X38,/*L*/
  25          #define segP   0X73,/*P*/
  26          #define segt   0X78,/*t*/
  27          #define seg-   0X40,/*-*/
  28          
  29          
  30          unsigned char seg0_f[]={
  31                  0XC0,/*0*/
  32                  0XF9,/*1*/
  33                  0XA4,/*2*/
  34                  0XB0,/*3*/
  35                  0X99,/*4*/
  36                  0X92,/*5*/
  37                  0X82,/*6*/
  38                  0XF8,/*7*/
  39                  0X80,/*8*/
  40                  0X90,/*9*/
  41                
  42                  0X88,/*A*/
  43                  0X83,/*b*/
  44                  0XC6,/*C*/
  45                  0XA1,/*d*/
  46                  0X86,/*E*/
  47                  0X8E,/*F*/
  48          
  49          #if 0
                      0X3F,/*0*/
                      0X06,/*1*/
                      0X5B,/*2*/
                      0X4F,/*3*/
                      0X66,/*4*/
C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 2   

                      0X6D,/*5*/
                      0X7D,/*6*/
                      0X07,/*7*/
                      0X7F,/*8*/
                      0X6F,/*9*/
              #endif
  61          
  62          };
  63          
  64          
  65          void segoff( unsigned char segbit)
  66          {
  67   1         if(segbit&0x1)
  68   1              segENA1=1;
  69   1         if(segbit&0x2)
  70   1              segENA2=1;
  71   1         if(segbit&0x4)
  72   1             segENA3=1;
  73   1         if(segbit&0x8)
  74   1             segENA4=1;
  75   1      /*
  76   1         switch bit {
  77   1           case 1:
  78   1              segENA1=1;
  79   1           case 2:
  80   1              segENA2=1;
  81   1           case 3:
  82   1              segENA3=1;
  83   1           case 4:
  84   1              segENA4=1;
  85   1           
  86   1         }
  87   1         */
  88   1      }
  89          
  90          void segon(unsigned char segbit) 
  91          {
  92   1         if(segbit&0x1)
  93   1              segENA1=0;
  94   1         if(segbit&0x2)
  95   1              segENA2=0;
  96   1         if(segbit&0x4)
  97   1             segENA3=0;
  98   1         if(segbit&0x8)
  99   1             segENA4=0;
 100   1         
 101   1      }
 102          
 103          
 104          #if 0
              void segchar(unsigned char c, unsigned char segbit)
              {
                 segoff(0xF);
                 segData = c;      
                 switch ( segbit ){
                   case 0:
                      segENA1=0;
                              break;
                   case 1:
                      segENA2=0;
                              break;
                   case 2:
C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 3   

                      segENA3=0;
                              break;
                   case 3:
                          segENA4=0;
                              break;
                       default:
                          ;
                   
                 }
              }
              #endif
 128          void testseg()
 129          {
 130   1         unsigned char n;
 131   1         segon(0xF);
 132   1                
 133   1         for(n=0;n<=9;n++){
 134   2                 segData = seg0_f[n];
 135   2                mdelay(128);
 136   2         
 137   2         }
 138   1         
 139   1         for(n=0;n<=9;n++){
 140   2                 segData = seg0_f[n] & segDOT;
 141   2                mdelay(128);
 142   2         }
 143   1      
 144   1      }
 145          
 146          
 147          void testvled()
 148          {
 149   1        unsigned char n;
 150   1        vledon();
 151   1        
 152   1        segData = 0xff;
 153   1        segData = 0;
 154   1        mdelay(255);
 155   1        segData = 0xff;
 156   1        mdelay(255);
 157   1         
 158   1        for(n=0;n<=8;n++){
 159   2                segData = ~(1<<n);
 160   2                mdelay(128);
 161   2        }
 162   1      
 163   1        vledoff();
 164   1      }
 165          
 166          /*===========================================================================*/
 167          /*
 168           * 数码管扫描显示 core
 169           */
 170          
 171          void segvled_init()
 172          {
 173   1         //power on test
 174   1         segoff(0xF);
 175   1         testseg();
 176   1         testvled();
 177   1        
 178   1         //close all
C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 4   

 179   1         segoff(0xF);
 180   1         vledoff();
 181   1      }
 182          
 183          
 184          
 185          /*
 186           *
 187           *  vblock[0] .... vblock[3]    vled
 188           *
 189           */
 190          //unsigned vblock[5]={0xFF,0xFF,0xFF,0xFF,0xFF};
 191          
 192          unsigned char vblock[5]={
 193                         segDOT,/*0*/
 194                         0XF9,/*1*/
 195                         0XA4,/*2*/
 196                         0XB0,/*3*/
 197                                     ~(0xf)};
 198          
 199          /*
 200           * 根据 vblock内容 扫描驱动数码管和电平管显示
 201           */
 202          void ms_scan_segvled() using 1 
 203          {
 204   1               static unsigned char block = 0;
 205   1               
 206   1               if(block<4){ //scan 4x8 seg
 207   2                  vledoff(); 
 208   2                      segoff(0xF);
 209   2                      segData = vblock[block];             
 210   2                  segon(1<<block);    
 211   2               }else { //scan vled
 212   2                     segoff(0xF);
 213   2                         segData = vblock[4];
 214   2                         vledon();
 215   2                         
 216   2                 
 217   2               } 
 218   1               block++;
 219   1               if(5 == block)
 220   1                 block = 0;
 221   1      
 222   1      }
 223          
 224          
 225          
 226          char vled_mode=0;
 227          
 228          /*
 229           *  更新显示内容, 实现vled mode
 230           *        : 电流,电压,HZ, 错误
 231           */
 232          void update_vled()
 233          {                    
 234   1      
 235   1           static unsigned long pos=0;
 236   1                      
 237   1               static unsigned long lasttime=0;
 238   1      
 239   1                      
 240   1                      
C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 5   

 241   1               if(! timeafter(jiffers,lasttime+80) )
 242   1                           return;
 243   1      
 244   1                      irqoff();   //disable global interrupt
 245   1                      if(vled_mode  == 0) //A mA
 246   1                vblock[4]= rol8(vblock[4], 1);
 247   1                      
 248   1                      if(vled_mode == 1){ //V mV
 249   2                              if(pos&0x4 ){     // pos&0x100 == 0x100 doesn't work!!!!!!!!
 250   3                                   vblock[4] = 0x5A;
 251   3                           }else{
 252   3                                   vblock[4] = 0xA5;
 253   3                           }
 254   2                      
 255   2                      }
 256   1      
 257   1                      if(vled_mode == 2){ //Hz
 258   2                               if(pos&0x2 ){
 259   3                       vblock[4] = 0x5A;
 260   3                               }else{
 261   3                                   vblock[4] = 0xFF;
 262   3                           }
 263   2                      }     
 264   1      
 265   1               if(vled_mode == 3) { //Err
 266   2                               if(pos&0x1 ){
 267   3                                   vblock[4] = 0xFF;
 268   3                       vblock[0]=vblock[1]=vblock[2]=vblock[3]=segDOT;
 269   3                                   
 270   3                                       
 271   3                           }else{
 272   3                                   vblock[4] = 0xFF;
 273   3                       vblock[0]=vblock[1]=vblock[2]=vblock[3]=0xFF;
 274   3                                   
 275   3                                       
 276   3                           }            
 277   2                       }     
 278   1                       
 279   1                      irqon();   //enable global interrupt
 280   1      
 281   1                      pos++;  
 282   1                      lasttime = jiffers;
 283   1               
 284   1      }
 285          void vledmod(char mod)
 286          {
 287   1         if(mod == 'A'){ //电流, 流水点亮三个vled
 288   2           vblock[4] = 0xF;
 289   2           vled_mode = 0;
 290   2         }
 291   1         if(mod == 'V'){ //电压, 两对vled向重点挤压
 292   2           
 293   2                vled_mode = 1;
 294   2         }
 295   1         if(mod == 'H'){ //HZ, 以一定频率闪烁vled
 296   2                vled_mode = 2;
 297   2         
 298   2         }
 299   1         if(mod == 'E'){ //err, 闪烁4个小数点
 300   2                vled_mode = 3;
 301   2         }
 302   1      
C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 6   

 303   1      
 304   1      }
 305          
 306          void vledx0()
 307          {
 308   1                 vblock[4] &= ~0x80;
 309   1                 
 310   1      }
 311          void vledx1()
 312          {
 313   1                 vblock[4] |= 0x80;
 314   1      }  
 315          
 316          #if 0
              void vled_flowtick()
              {
                static char n=0; 
                vledon();
              
                segData = ~(1<<n);
              
                if(7==n)
                    n=0;
                else
                    n++;
              
                vledoff();
              }
              #endif
 332          
 333          
 334          /*
 335           *  循环 4种提示模式, 演示用
 336           */
 337          void segvled_demo()
 338          {
 339   1      
 340   1              static unsigned long mode_show_time=0;
 341   1      
 342   1              if(timeafter(jiffers,mode_show_time+4*5000)){ //3s
 343   2                              
 344   2      
 345   2                                if(vled_mode == 3){ //从3模式, err退出,随机重置所有数码管
 346   3                                   vblock[4]= 0xFF;
 347   3      
 348   3                                       vblock[1]= seg0_f[(jiffers)>>5&0xf];
 349   3                                       vblock[2]= seg0_f[(jiffers)>>7&0xf];
 350   3                                       vblock[3]= seg0_f[jiffers&0xf];
 351   3                                       
 352   3                                       vblock[0]= segDOT;
 353   3                                } 
 354   2                                      
 355   2                                
 356   2                                vled_mode++;
 357   2                                vled_mode&=0x3;
 358   2                    
 359   2                                if(vled_mode == 0 )
 360   2                               vledmod('A');                   
 361   2                                
 362   2                                mode_show_time = jiffers;
 363   2                                
 364   2                      }
C51 COMPILER V8.01   4X8SEG_VLED                                                           10/18/2009 22:06:08 PAGE 7   

 365   1      }
 366          
 367          
 368          
 369          void printhex(unsigned short n)
 370          {
 371   1           //irqoff();
 372   1               vblock[0]= seg0_f[ (n/1000) ];
 373   1               n = n%1000;
 374   1               vblock[1]= seg0_f[ n/100 ];
 375   1               n = n%100;
 376   1                              
 377   1               vblock[2]= seg0_f[(n/10)];
 378   1               vblock[3]= seg0_f[ (n%10)];
 379   1               //irqon();
 380   1      }
 381                             
 382                             


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    734    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
