<html><head>
<meta http-equiv="content-type" content="text/html; charset=GB2312">

<title>Shift1-LCD Projects</title> 
<meta name="description" content="Roman Black's Shift1-LCD kit projects">
<meta name="keywords" content="PIC, Shift1, Shift1-LCD, Shift Register,
1-wire shift register, Shift1 System, Shift1 Protocol">

<!-- ---------------------------------------------------------------------->
</head><body alink="#cc0000" bgcolor="#000000" vlink="#aa40aa" text="#cccccc" link="#6060ff">

<font face="Arial,Helvetica,Verdana,Geneva,sans-serif">
<font size="-1"> <!-- default font-->
<!-- ---------------------------------------------------------------------->
<font size="2">
<a href="http://www.romanblack.com/index.htm#elec">[Back to Home Page]</a></font>
<br>
<br>

<!-- ---------------------------------------------------------------------->
<font color="#ccaa66" size="+1"><b>www.RomanBlack.com</b></font>
<br>
<br>


<!-- ---------------------------------------------------------------------->
<font color="#ccaa66" size="+2"><b>Shift1-LCD projects</b></font><br>
<b>Things you can make with a Shift1-LCD kit!</b>
- 3rd Nov 2009.
<br>
<br>
<br>

<img src="sh1_projects_files/sh1_plusPIC.jpg">
<br>
<br>
<br>

<font size="+1"><a href="http://www.romanblack.com/shift1.htm">
<b>Click HERE to see my Shift1-LCD "how it works" page</b></a></font>

<br>
<br>
<br>
<!-- ---------------------------------------------------------------------->
<!-- ---------------------------------------------------------------------->
<!-- ---------------------------------------------------------------------->


<!-- ---------------------------------------------------------------------->
<font color="#ccaa66" size="+1"><b>About these projects</b></font>
<!-- ---------------------------------------------------------------------->
<br>
<br>

The <b>Shift1-LCD</b> is a low-cost kit I designed that lets you use
1 PIC pin to control an entire LCD and backlight.
<br>
It also has an option of using an on-board 8pin <b>PIC 12F675</b> to make a
complete device, all smaller than the LCD itself!
<br>
<br>

These following projects are open-source, you can use them as you like
but please mention me and my Shift1-LCD system if you use my source code.
<b>The Shift1-LCD kit is
<a href="http://techref.massmind.org/techref/io/lcd/Shift1_assemble.htm" target="_blank">
<b>Available here!</b></a>
<br>
<br>

Wherever possible the following projects are complete, ie <b>all you need
is a Shift1-LCD kit, an LCD, and a few external parts</b> to make a complete
device. I have included all source code and hex files where possible.
<br>
<br>
<br>


<!-- ---------------------------------------------------------------------->
</b></font></font><hr><font face="Arial,Helvetica,Verdana,Geneva,sans-serif"><font size="-1"><b><br>
<font color="#ccaa66" size="+1"><b>+5v regulator option</b></font>
<!-- ---------------------------------------------------------------------->
<br>
<br>

<img src="sh1_projects_files/sh1p_7805.jpg">
<br>
<br>
<br>

The Shift1 PCB has an un-connected pin marked V, it is the first pin on
the 10 pin header.
<br>
<br>

This can be used for easy mounting of a standard 7805 +5v regulator. The
regulator is soldered on the bottom of the PCB and connects to the first 3 pins;
</b><li><b> V (Vin)
</b></li><li><b> Gnd
</b></li><li><b> +5v

<br>
<br>
<br>


<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Clock</b></font> &nbsp; 3rd Nov 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option and 8MHz xtal - 1x8 or 1x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_clock.jpg">
<br>
<br>
<br>

<b>This is a simple 12-hour clock</b> (like an alarm clock). It just displays
the time on the LCD.
<br>
<br>

There is <b>ONE button to set the clock</b> on pin GP1 (LO = pressed);<br>
</b></li><li><b> hold button - changes hours
</b></li><li><b> quick-press button - changes minutes (and reset seconds)
<br>
<br>

<b>Note1</b>
I only used one button for clock setting as that allows 2 spare PIC pins
to use for in/outs. ie you can add inputs to start/stop a timer,
or outputs to turn stuff on/off by the clock.
<br>
<br>

<b>Note2</b>
The system to generate each second is
<a href="http://www.romanblack.com/one_sec.htm" target="new">
<b>my zero-error 1-second timer system</b></a>
that uses a long constant (8000000) to represent the 8MHz xtal.
This long constant can be adjusted to give very fine control of time
to "trim" the clock to be very accurate.
<br>
<br>


The source code is very simple and can easily be adapted to make
event timers, countdown timers, time controllers etc. It only needs
a single-line LCD but will work fine on a dual line LCD too.
<br>
<br>

Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Clock.zip">SH1_Clock.zip</a></b>
</font> 14 kb


<br>
<br>
<br>


<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Servo</b></font> &nbsp; 3rd Nov 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option and 8MHz xtal - 1x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_servo.jpg">
<br>
<br>
<br>

<b>This is a tester for RC Servos</b> It has a pot, when the pot is
turned the Servo turns the same. There are 2 ranges to give Servo pulse
width of 1000uS-2000uS or 500uS-2500uS. The pulse width is displayed on
the LCD as actual microseconds, which is handy for setting up RC Servos.
<br>
<br>

</b></li><li><b> GP0 - pot wiper (ADC input), the pot controls servo
</b></li><li><b> GP1 - digital output, servo pulse out
</b></li><li><b> GP3 - "range" button, low = pressed (needs 10k pullup resistor!)
<br>
<br>

Note! Add a 100uF cap from GP0 to ground. This reduces noise picked
up by the ADC and gives smoother servo operation.

<br>
<br>

Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Servo.zip">SH1_Servo.zip</a></b>
</font> 16 kb


<br>
<br>
<br>
<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Charge</b></font> &nbsp; 3rd Nov 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option (no xtal) - 2x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_charge.jpg">
<br>
<br>
<br>

This is a <b>battery charge controller</b> for use in solar or wind
power installations. It measures the battery voltage and displays it.
It also has an adjustable SetPoint, when the battery voltage is over
the setpoint it turns the "load" on, ie sets a PIC pin high, and
displays "LOAD" on the LCD. This automatically controls the battery
charge so the battery cannot be overcharged and damaged.
<br>
<br>

This project is quite sophisticated, the Setpoint voltage you select
is stored on the PIC internal eeprom so it is there on any power up.
Also there are 4 battery voltage ranges, enough choices to suit
all battery systems (6v 12v 24v 36v 48v). The battery range is also
stored in eeprom.
<br>
<br>

<b>Adjustment is done very simply by 2 buttons.</b> These adjust the SetPoint
UP and DOWN, first in 0.02v steps then in 0.1v steps. If both buttons
are pressed at the same time, the VOLTAGE RANGE changes.
<br>
<br>

<b>Input of battery voltage is via an external pot</b> (10k or 50k)
connected to GP0.
This "trims" the battery voltage to display correctly. There should
also be a large cap from GP0 to ground, about 220uF or 470uF. This
smoothes any spikes etc on the battery voltage caused by other
equipment.
<br>
<br>


<b>Output is from 2 PIC pins, GP4 and GP5.</b> These are opposite to each
other, so you can use them as high-side or low-side drivers etc,
usually to turn a relay ON or OFF as needed. This makes it easy to
use the device to turn something ON when battery is too full,
or turn something OFF when battery is too full, or both. 


<br>
<br>

</b></li><li><b> GP0 - pot wiper (ADC input), a 5k or 10k pot controls servo
</b></li><li><b> GP1 - button - adjust SetPoint UP (lo = pressed)
</b></li><li><b> GP3 - button - adjust SetPoint DOWN (lo = pressed)(needs 10k pullup resistor!)
</b></li><li><b> (GP1+GP3 - both pressed - changes voltage display Range)
</b></li><li><b> GP4 - out - control load
</b></li><li><b> GP5 - out - control load (inverted)
<br>
<br>

<b>Note!</b> Once the battery voltage reaches the setpoint and the
LOAD turns ON, it will remain on for a minimum of 10 seconds
duration. That is a safety feature for situations where the load
might be a water pump etc, it will always run for at least 10
seconds.
<br>
<br>

Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Charge.zip">SH1_Charge.zip</a></b>
</font> 20 kb
<br>
<br>
<br>

<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Tacho</b></font> &nbsp; 4th Nov 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option and 8MHz xtal - 1x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_tacho.jpg">
<br>
<br>
<br>

<b>This tacho measures the RPM of machinery</b> like lathes and drill
presses, engines etc.
<br>
<br>


It measures RPM based on period (xtal locked) over 4 pulses to give an
accurate RPM measurement. It has another RPM display (shown on the right)
which is an average of the 4 previous RPM measurements (an average 
of 16 pulses).
The average RPM is a useful display to show real time RPM of machinery
where the speed is constantly fluctuating slightly due to cutting or
drilling cycles etc.
<br>
<br>

The tacho has 4 ranges, these select how many pulses per rev
(which is based on the machine rotor). The choices are 1, 2, 4, 8
pulses per rev. For slow turning machinery (lathes, drill presses)
an 8 pulse per rev rotor is best because it gives a lower RPM measuring
ability. For faster machinery (grinders, high speed PCB drills) then
1 pulse per rev rotor is best because it will give finer measurement
but not be able to measure very low speeds. As an example; if your
machine will not be operated below 240 RPM then you are best with
the 1 pulse per rev rotor.
<br>
<br>

<b>The 4 rotor types are set by PIC pins GP1 and GP0;</b>
</b></li><li><b> GP1=1 GP0=1 = 1 pulse per rev; max RPM = 65000, min RPM = 240
</b></li><li><b> GP1=1 GP0=0 = 2 pulse per rev; max RPM = 65000, min RPM = 120
</b></li><li><b> GP1=0 GP0=1 = 4 pulse per rev; max RPM = 65000, min RPM = 60
</b></li><li><b> GP1=0 GP0=0 = 8 pulse per rev; max RPM = 65000, min RPM = 30
<br>
<br>

The signal pulse from the rotor must be digital level (0v-5v)
and connected to PIC pin GP3.
<br>
<br>

<b>Note!</b> Because the measurement is done by period (for accuracy)
the display updating time is based on machine speed. At very low
RPMs the display will update every 2-3 seconds. At higher RPMs the
display will update much faster, like a few times a second.
<br>
<br>


Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Tacho.zip">SH1_Tacho.zip</a></b>
</font> 17 kb


<br>
<br>
<br>

<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Temp</b></font> &nbsp; 5th Nov 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option (no xtal) - 2x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_temp.jpg">
<br>
<br>
<br>

This is a <b>temperature controller using a LM335 temp sensor</b>
that can be used to control incubators, drying ovens, refrigerators,
freezers etc.
<br>
<br>

The LM335 sensor is a cheap and common temperature sensor that
will read from -40'C to +100'C. It's output is calibrated in
degrees Kelvin so this project converts that to degrees Celcius.
The LCD shows the measured temperature in 'C on the top line,
and the temperature Setpoint on the bottom line.
Also on the bottom line (left) the display shows HEAT or COOL
depending on what the device is doing.
<br>
<br>


<b>Adjustment is done very simply by 2 buttons.</b>
These adjust the SetPoint UP and DOWN, first in 0.5'C steps then 
in 2.5'C steps. The setpoint adjustment is stored in PIC eeprom
so it will remain, even after a power cut etc.
<br>
<br>

The temperature sensor is connected with its + pin to PIC pin GP0.
The sensor - pin is connected to Ground and its Adj pin is not
connected. You will probably need a capacitor from GP0 to Ground
(try 47uF) connected at the PCB terminals (not on the sensor itself).
The cap will reduce noise that causes jittery readings.
<br>
<br>

<a href="http://www.romanblack.com/shift1/LM335_temp_sensor.pdf">
<b>LM335 temp sensor datasheet here.</b></a> 877 kb
<br>
<br>


<b>Output is from 2 PIC pins, GP4 and GP5.</b> These are opposite to each
other, so you can use them as high-side or low-side drivers etc.
Generally the PIC pin GP4 would control a logic-level relay (or turn
on a transistor to operate a relay), and that relay would control
the heater.


<br>
<br>

</b></li><li><b> GP0 - (ADC input), connects to LM335 + pin (also put a cap here)
</b></li><li><b> GP1 - button - adjust SetPoint UP (lo = pressed)
</b></li><li><b> GP3 - button - adjust SetPoint DOWN (lo = pressed)(needs 10k pullup resistor!)
</b></li><li><b> GP4 - out - control heat
</b></li><li><b> GP5 - out - control heat (inverted)
<br>
<br>


Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Temp.zip">SH1_Temp.zip</a></b>
</font> 19 kb
<br>
<br>
<br>

<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Temp_2</b></font> &nbsp; 14th Nov 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>
<br>

<a href="http://www.romanblack.com/shift1/sh1_p2.htm">
<img src="sh1_projects_files/sh1p_p2_lcd.jpg">
<br>
<br>

<font size="+1"><b>
NEW! A complete drying-oven controller for paint curing!</b></font></a><font size="+1"></font>

<br>
<br>
<br>

<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Counter</b></font> &nbsp; 29th Nov - Web 16th Dec 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option (no xtal) - 1x16 or 2x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_counter.gif">
<br>
<br>
<br>

<b>This is a counter,</b> actually it is 2 independent counters.
Each counter has 16 digits so they can count REALLY big numbers,
each 16 digit counter will count up to 10 thousand trillion!
<br>
<br>

If the PIC pin GP5 is held LOW it only uses one counter, this feature
lets you use a 1x16 LCD and just use a single counter. Otherwise there
is a separate 16 digit counter on each line of the 2x16 LCD.
<br>
<br>


<b>PIC pins;</b>
</b></li><li><b>  GP0 - counter 1 signal in, inc counter1 on \ edge
</b></li><li><b>  GP1 - counter 2 signal in, inc counter1 on \ edge
</b></li><li><b>  GP3 - low = reset counter 1 (needs 10k pullup resistor)
</b></li><li><b>  GP4 - low = reset counter 2
</b></li><li><b>  GP5 - low = 1 counter, hi (default) = 2 counters
<br>
<br>

The 2 counter inputs are debounced in software, so they must be
pulled low for &gt;7mS to make a count. This debounce has been tuned to
work with most mechanical switches, pushbuttons, microswitches,
magnetic reed switches etc if the counter is to be used on a
machine. The debounce gives a decent immunity to contact bounce
which would cause extra counts!
<br>
<br>

Maximum count rate is about 5 counts per second if clocking
both counters at the same time, otherwise is about 10 counts per
second if using just one counter (or if just clocking one counter).
<br>
<br>

The software is very simple and uses my own nifty <b>system for making
an unlimited-digits counter by storing the count only as text,</b>
so the little PIC still only needs to work with single byte
variables (no longs, doubles etc). My counter routine is
fast executing and can have unlimited digits (limited only by the
length of the text character string), and it also supports leading
blanks;
<br>

<font size="+0"><pre><code><font color="#ffffff">
<font color="#cedcff"><i>//=============================================================================</i></font>
<font color="#cedcff"><i>//   INC COUNTER</i></font>
<font color="#cedcff"><i>//=============================================================================</i></font>
<font color="#cf9bff"><b>void</b></font> inc_counter(<font color="#cf9bff"><b>unsigned char</b></font> *icount)
{
  <font color="#cedcff"><i>//-----------------------------------------------------</i></font>
  <font color="#cedcff"><i>// the counter values are stored as text.</i></font>
  <font color="#cedcff"><i>// so inc them using a special procedure starting</i></font>
  <font color="#cedcff"><i>// at the final (right) character then working back.</i></font>
  <font color="#cedcff"><i>//-----------------------------------------------------</i></font>
  <font color="#cedcff"><i>// loop and inc the counter</i></font>
  i = <font color="#faff9d"><b>15</b></font>;
  <font color="#cf9bff"><b>while</b></font>(i &lt; <font color="#faff9d"><b>16</b></font>)
  {
    <font color="#cf9bff"><b>if</b></font>(icount[i] &lt; <font color="#ffa395">'0'</font>) icount[i] = <font color="#ffa395">'0'</font>; <font color="#cedcff"><i>// change digit to '0' before inc it</i></font>
    icount[i]++;                         <font color="#cedcff"><i>// inc the digit</i></font>

    <font color="#cf9bff"><b>if</b></font>(icount[i] &lt;= <font color="#ffa395">'9'</font>) <font color="#cf9bff"><b>break</b></font>;          <font color="#cedcff"><i>// if no digit roll, inc is done</i></font>
    icount[i] = <font color="#ffa395">'0'</font>;                     <font color="#cedcff"><i>// digit roll, so clr it, and inc next</i></font>
    i--;
  }
  <font color="#cedcff"><i>// check for final roll and do a counter reset, to put blanks back in</i></font>
  <font color="#cf9bff"><b>if</b></font>(icount[<font color="#faff9d"><b>0</b></font>] == <font color="#ffa395">'0'</font>) clear_counter(icount);
}
<font color="#cedcff"><i>//-----------------------------------------------------------------------------</i></font>
</font>
</code></pre></font>
<br>

Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Counter.zip">SH1_Counter.zip</a></b>
</font> 14 kb
<br>
<br>
<br>


<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<font color="#ccaa66" size="+1"><b>SH1_Morse</b></font> &nbsp; 29th Nov - Web 16th Dec 2009
<!-- ---------------------------------------------------------------------->
<br>
<br>

<b>Requires Shift1-LCD with PIC 12F675 option (no xtal) - 2x16 LCD</b>
<br>
<br>
<br>

<img src="sh1_projects_files/sh1p_morse.gif">
<br>
<br>
<br>

<b>This is a Morse code trainer</b> that plays the Morse code as standard
timed beeps through the speaker and also displays it as text on the LCD.
<br>
<br>

It is reasonably sophisticated, as least as far as the 1k ROM limit on the
PIC 12F675 will allow. The Morse characters use proper timing and the WPM
can be selected by the user from 5 to 35 WPM in 31 separate adjustments.
WPM is official and based on the Paris standard. The intra-character and
character and word spacing are all standard. Output audio frequency
is 750 Hz.
<br>
<br>

There is a further adjustment, from 0 to 0.5 to 1.0 T. This adds up to 1T
extra pause between Morse characters. This makes it a bit easier to
distinguish individual characters.
<br>
<br>


<b>PIC pins;</b>
</b></li><li><b> GP0 - button, WPM UP, lo=pressed
</b></li><li><b> GP1 - button; WPM DOWN, lo=pressed
</b></li><li><b> GP3 - button; Change T, lo=pressed (needs 10k pullup ressstor)
</b></li><li><b> GP4 - morse code 750Hz out to speaker, use 500 ohm pot and 180 ohm resistor.
</b></li><li><b> GP5 - (not used)<br>
<br>

I connected a small 8 ohm speaker from PIC pin GP4 to ground, through a
500k pot and 180 ohm resistor (all in series). This gave volume adjustment
from barely audible to "annoying" although it is not loud.
<br>
<br>

<b>Operation.</b> I wanted to build a Morse trainer for a while, that
could run in the background while I did internet tasks etc. 
The user just listens to the beeps and guesses the "word". A quick
glance at the LCD shows if they got the word right. This is instinctive
and seems a good way to learn while doing other tasks (although beware
the beeping has been known to cause wife annoyance!).
<br>
<br>

I tried a few systems to see if I could come up with a system to let
the user learn Morse without too much effort or boredom. After a while I
settled on the 4 second delay, followed by a random 3 letter word which
repeats 4 times. This allows full speed Morse learning (similar to Koch
nethod) but has a number of benefits as the repeat allows a second or
third attempt (etc) to "hear" the word. This is a very "human" way of
learning, we all do that "say it again?" thing if we didn't quite make
something out.
<br>
<br>

There are 26 words of 3 letters, all the alphabet letters are represented.
Grouping the letters into words allows for the user to learn the "flow"
of letters strung together. The random generator has a 50% chance of making
a word, and a 25% chance of just making a single letter or number. This
breaks up the session and also allows a chance to identify a single
character.
<br>
<br>

It seems to work ok. After a couple of easy sessions I was able to
recognise many of the words without looking up, even at 25 WPM. I'm sure
after enough sessions it would just become second nature that is if your
wife doesn't smash "that #%^$&amp; beeping thing" first haha.
<br>
<br>

<b>Other uses!</b> This code contains my Morse data table that is very code
efficient as it only uses one byte for every Morse character, that byte
defines BOTH the length of the character and also its Dits and Dahs.
There is also some small efficient code to generate precise "standard"
timed Morse (at any WPM) so the code may be useful to adapt to RF devices
etc so they can transmit simple data in Morse.
<br>
<br>


Source code in MikroC, also HEX file etc; 
<font size="+1"><b>
<a href="http://www.romanblack.com/shift1/SH1_Morse.zip">SH1_Morse.zip</a></b>
</font> 23 kb
<br>
<br>
<br>







<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<!-- ---------------------------------------------------------------------->
<br>

<img src="sh1_projects_files/Shift1_pcb.gif">
<br>
<br>
<br>

<font size="+1">
Buy Kits here! 
<a href="http://techref.massmind.org/techref/io/lcd/Shift1_assemble.htm" target="_blank"><b>Shift1-LCD Kits</b></a></font>
<br>
<br>



<font size="+1">
Or click here to go back to my 
<a href="http://www.romanblack.com/shift1.htm">
<b>Shift1-LCD "how it works" page</b></a>
for more photos and schematics.</font>


<br>
<br>
<br>

<!-- ---------------------------------------------------------------------->
</b><hr><b><br>
<!-- ---------------------------------------------------------------------->
 - end - 
<br>
<br>

<font size="2">
<a href="http://www.romanblack.com/index.htm#elec">[Back to Home Page]</a>
</font>

<br>
</b></li></font>
</font></body></html>